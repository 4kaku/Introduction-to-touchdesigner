\cleardoublepage
\chapter{COMPs}
\label{ch:7}

%------------------------------------------------

\section{Introduction}

\begin{fullwidth}
There are 3 types of Component Operators, or COMPs, and each have different uses:

\begin{description}
\item[Object] components create, light, and view 3D scenes
\item[Panel] components create UI components such as buttons, sliders, and window panes
\item[Other] components include components that create keyframe animations, replicate other Operators, and create output windows
\end{description}

Component Operators are generally used in conjunction with other Operators. The 'Object' components are used in various combinations to create and render SOPs and 3D scenes. The 'Panel' components are used to create UIs and various containers to create output rasters. The 'Other' components are used for various tasks, such as keyframe animations, dynamic Operator replication, opening windows on various displays, etc.

An interesting fact to put things in perspective is that a large amount of TouchDesigner is made from components inside of TouchDesigner. Understanding this really helps in grasping the granularity of TouchDesigner, and how to approach working on various projects. For example, all Panel components are made of other Operators. Create a Button COMP, and inside it's Network, it's background is made of a Text TOP, and its on/off values are being generated by a Panel CHOP. Similarly, all of TouchDesigner's UI is made and stored in the 'ui' container in the root of all projects. Even the menus and dialogs, like the MIDI Mapper Dialog and the Variables Dialog, are created using other TouchDesigner components.

\end{fullwidth}

%------------------------------------------------

\section{Window COMP}

\begin{fullwidth}
The Window COMP is used in almost every project to display the contents of an Operator in a new window. Whether using the Window COMP to create a full-screen output, or to create more of a traditional windowed application, there are a number of options that will need modifying. Because of the unique nature of every project, there are no 'best settings' to consistently rely on. Spend some time and go over the parameters on the Wiki, and experiment to find works best in each and every new situation.

Open example 'Window.toe'. This example demonstrates a very helpful practice, as well as some simple Window COMP functionality. It is best practice to use a Container COMP as the source of the Window COMP's output. This is because the texture in a TOP can be dragged around the screen, even in Perform Mode. If this happens, the texture will remain shifted until the project is reloaded, or until the texture is moved back to it's original position. The same texture shifting doesn't occur to Container COMPs. The texture inside of a Container COMP cannot be dragged around by default, meaning the texture will always be consistent.

The other functionality in this example is rather simple. The first is a button, whose Null CHOP is being referenced in the 'Open Window' parameter of the Window COMP. This allows easy access to the opening and closing of the window. The next is a button that dynamically checks how many monitors are connected, by getting a row count from the recently implemented Monitors DAT. Using that value to cycle a Count CHOP, open the window with the first button, then use the second button to cycle through which monitor this window is assigned to.
\end{fullwidth}

%------------------------------------------------

\section{User Interface Components}

\begin{fullwidth}
Component Operators are incredibly important as they create user interfaces in TouchDesigner. Specifically, the Panel Components are what provide this functionality. Many user interfaces will be created in later examples, so only a few basic examples will be examined in this section. 

Three of the most useful Panel COMPs are:

\begin{itemize}
\item the Slider COMP
\item the Button COMP
\item Container COMP
\end{itemize}

The first two function with the same capabilities as sliders and buttons in other applications, but can be modified to suit different requirements. Buttons can be programmed as toggles, radios, or momentary buttons. Sliders can function as single axis sliders, or as full XY pads. 

Container COMPs, on the other hand, don't have a function other than acting as a container for other UI elements. 

Open example 'UI.toe'. In this example, there is a simple UI. From the bottom of the Network upwards, there are the 2 Button COMPs and the 5 Slider COMPs. These are the components that are actually creating the UI's functionality. The parent of these elements, is used to group and arrange the buttons and sliders separately. Notice that if the viewers for 'container1' or 'container2' are activated, the UI elements are usable, but neither 'container1' or 'container2' have any outputs or Operators in their Networks. Similarly, the results are the same when 'container1' and 'container2' are combined inside of 'container3'. This is because Container COMPs have the ability to display their children in their viewers. Container COMPs facilitate the creation of complex interfaces using a combination of smaller pieces.


\end{fullwidth}